+dk ffinterface
+if ffield
!! ---------------------------------------------------------------------------
!!      Interface with SixTrack
!! ---------------------------------------------------------------------------
!!      workChoise    0  - Import config file
!!                    1  - Import data file
!!                    2  - Symplectic integration
!!                    11 - Test import data file
!!                    6  - Free all the memory
!!                    3  - Allocate table for particle out of boundary
subroutine ffInterface (workChoise, currQuad, ffi, ffj, ffn)
   implicit none
   
   ! Definition of the ffTable type
   ! -------------------------------------------------------------------------
   type ffTable
     integer :: n,m,s                                                      ! Exposant maximum pour x et y, Nombre de point en z
     integer :: lx,ly,lz                                                   ! Number of coef per step
     integer(kind=2),dimension(:,:,:),allocatable :: ij_TAx,ij_TAy,ij_TAz  ! Tableau des indices ij de Ax, Ay et Az
     double precision :: dz, norm, Lgth                                    ! Taille du pas en z et normalisation
     double precision,dimension(:,:),allocatable :: TAx,TAy,TAz            ! Nouveau tableau des coefficients de Ax, Ay et Az
     double precision,dimension(:,:,:),allocatable :: AQx,AQy
     logical,dimension(:),allocatable :: checkAQ
   end type ffTable

   ! Espace commun de SixTrack 
   ! -------------------------------------------------------------------------
+ca parpro   

+ca parnum
   
+ca commonmn

+ca common

!   <<<<<<<<<<<<<< test 07-03-2018
+ca commonm1
!   <<<<<<<<<<<<<< test 07-03-2018

+ca commontr

   ! Initialisation de l'espace commun
   ! -------------------------------------------------------------------------
+ca ffieldcommon

+ca ffieldcommon1

   ! Initialisation des parametres physique
   ! -------------------------------------------------------------------------
!!$   double precision :: Eproton, Etot, gamma0, beta0, p0, clight, norm !, e0
   double precision :: Etot, gamma0, beta0, p0, norm !, e0
!!$   parameter (clight=299792458.)                 ! Vitesse de la Lumiere [m/s]
!!$   parameter (Eproton=9.382720134258239e2)       ! Mass d'un proton [MeV] 
!   parameter (e0=1.60217653e-19)                   ! Energie de reference 
   parameter (Etot=0.0d0*pmap+7.0d0*c1e6)           ! Energie totale du systeme [MeV]
   parameter (gamma0=Etot/pmap)                     ! Ratio entre l'energie totale et celle d'un proton
   parameter (beta0=sqrt(1.0d0-1.0d0/gamma0/gamma0))! Parametre beta0
   parameter (p0=beta0*Etot*c1e6/clight)            ! Reference momentum [eV/c] 
   !parameter (p0=7.e12)
   

   ! Function parameters
   ! -------------------------------------------------------------------------
   integer :: workChoise, ffj, ffi, ffn
   integer, dimension(2) :: currQuad  


   ! Static variables
   ! -------------------------------------------------------------------------
   logical, allocatable, dimension(:), save :: ffImported     ! Static matrix one if the correspond file is already imported
   type(ffTable), allocatable, dimension(:), save :: ffTA     ! Static vector containing all the data
   integer, allocatable, dimension(:,:,:,:), save :: ffloss   ! Static matrix 
   logical, allocatable, dimension(:,:), save :: ffnotIN        ! Static matrix 
   logical, save :: firstTime = .true.                        ! Static variable that check config's file was found
   logical, save :: firstTime2 = .true.                       ! Static variable that check allocation table particle with (x*x+y+y)>r*r
   

   ! Useful variables
   ! -------------------------------------------------------------------------
   integer :: i, j, k, dataindex, sum_loss_in, sum_loss_out
   logical :: OKRead


   ! Variables that will be eliminated
   ! -------------------------------------------------------------------------
   double precision :: x, px, y, py, zb, delta, gam0
   double precision :: stracki
   character(len=512) :: inex


   ! Definition of the interface
   ! -------------------------------------------------------------------------
   interface
      subroutine CreateVectCoef(FileName,n,m,s,dz,Lgth,lx,ij_Ax,TAx,ly,ij_Ay,TAy,lz,ij_Az,TAz,norm,OKRead)
         character(len=*) :: FileName
         logical OKRead
         integer :: n,m,s
         integer :: lx,ly,lz
         integer(kind=2), dimension (:, :, :) :: ij_Ax,ij_Ay,ij_Az
         double precision :: dz,norm,Lgth
         double precision, dimension (:, :) :: TAx,TAy,TAz
      end subroutine

      subroutine fftest(n,m,s,dz,Lgth,lx,ij_TAx,TAx,ly,ij_TAy,TAy,lz,ij_TAz,TAz,norm)
         integer :: n,m,s
         integer :: lx,ly,lz
         integer(kind=2), dimension (:, :, :),allocatable :: ij_TAx,ij_TAy,ij_TAz
         double precision :: dz,norm,Lgth
         double precision, dimension (:,:),allocatable :: TAx,TAy,TAz
      end subroutine
   end interface 


   ! ??????????????????????
   ! -------------------------------------------------------------------------
   if (.not.firstTime) then
      dataindex = ffQ2File(currQuad(1), currQuad(2))
   
   else
      ffReady = .false.
      
   endif
   

   ! 0 : Import the configuration file
   ! -------------------------------------------------------------------------
   if (workChoise == 0) then
     
      if (.not.firstTime) then
         write(*,*) 'FringeField ERROR: The config file was already imported'
         return
      endif      
      call ReadconfigFile
      
      if (ffReady .eqv. .true.) then
         allocate(ffTA(1:ffNLFile))
         allocate(ffImported(1:ffNLFile))
         ffImported = .false.
         firstTime = .false.
         write (*,*) 'FringeField : Config file imported '
         
      else
         write (*,*) 'FringeField : Config file NOT imported'
         
      endif

   ! 1 : Import data files
   ! -------------------------------------------------------------------------
   else if ((workChoise == 1).and.(.not.firstTime)) then
      if (ffImported(dataindex)) then
         write(*,*) "FringeField : ",ffFNames(dataindex)," Already imported!"
      else
         
         ffTA(:)%norm = 1.0d0/p0
         call CreateVectCoef(ffFNames(dataindex),   &
                             ffTA(dataindex)%n,     &
                             ffTA(dataindex)%m,     &
                             ffTA(dataindex)%s,     &
                             ffTA(dataindex)%dz,    &
                             ffTA(dataindex)%Lgth,  &
                             ffTA(dataindex)%lx,    &
                             ffTA(dataindex)%ij_TAx,&
                             ffTA(dataindex)%TAx,   &
                             ffTA(dataindex)%ly,    &
                             ffTA(dataindex)%ij_TAy,&
                             ffTA(dataindex)%TAy,   &
                             ffTA(dataindex)%lz,    &
                             ffTA(dataindex)%ij_TAz,&
                             ffTA(dataindex)%TAz,   &
                             ffTA(dataindex)%norm,  &
                                         OKRead)
         if (.not.OKRead) then
            write(*,*) "FringeField ERROR : I couldn't read this file ", ffFNames(dataindex)

         else
            ffImported(dataindex) = .true.
            
            
            ! Allocate memmory for AQ
            Allocate(ffTA(dataindex)%AQx(1:2,1:2,1:npart),ffTA(dataindex)%AQy(1:2,1:2,1:npart), &
                     ffTA(dataindex)%checkAQ(1:npart))
            do j=1,npart
              ffTA(dataindex)%AQx(1,1,j)=0;              ffTA(dataindex)%AQx(1,2,j)=0;
              ffTA(dataindex)%AQx(2,1,j)=0;              ffTA(dataindex)%AQx(2,2,j)=0;
              ffTA(dataindex)%AQy(1,1,j)=0;              ffTA(dataindex)%AQy(1,2,j)=0;
              ffTA(dataindex)%AQy(2,1,j)=0;              ffTA(dataindex)%AQy(2,2,j)=0;
              ffTA(dataindex)%checkAQ(j)=.true.
            enddo
            
            
            
            if (abs(ffTA(dataindex)%Lgth - ffParam(dataindex,6)) > 1E-12) then
               write(*,*) "FringeField WARNING: The length in the Config file and computed are different: ", &
                          ffParam(dataindex,6), " != ", ffTA(dataindex)%Lgth
               write(*,*) "                     We use the computed one!"
            endif
 
         endif
         write (*,*) "FringeField : ", ffFNames(dataindex) , " imported! "
      endif


   ! 11 : Test
   ! -------------------------------------------------------------------------
   else if ((workChoise == 11).and.(.not.firstTime)) then
      call fftest(ffTA(dataindex)%n,     &
                  ffTA(dataindex)%m,     &
                  ffTA(dataindex)%s,     &
                  ffTA(dataindex)%dz,    &
                  ffTA(dataindex)%Lgth,  & 
                  ffTA(dataindex)%lx,    &
                  ffTA(dataindex)%ij_TAx,&
                  ffTA(dataindex)%TAx,   &
                  ffTA(dataindex)%ly,    &
                  ffTA(dataindex)%ij_TAy,&
                  ffTA(dataindex)%TAy,   &
                  ffTA(dataindex)%lz,    &
                  ffTA(dataindex)%ij_TAz,&
                  ffTA(dataindex)%TAz,   &
                  ffTA(dataindex)%norm)
      ffImported(dataindex) = .true.
      write (*,*) 'workChoise == 11'


   ! 12 : Test
   ! -------------------------------------------------------------------------
   else if (workChoise == 12) then
!     if (ffi == 1) then !(.false.) then !
!       do ffj = 1,napx
!         if (.true..or.(nlostp(ffj) == 1).or.(nlostp(ffj) == 9).or.(nlostp(ffj) == 10).or.            &
!             (nlostp(ffj) == 15).or.(nlostp(ffj) == 16)) then
!           write(*,*) "12 21 ", ffi, ffn, ffj, nlostp(ffj), xv(1,ffj), yv(1,ffj), xv(2,ffj),&
!                       yv(2,ffj), dpsv(ffj), dpd(ffj), oidpsv(ffj)
!         endif
!   <<<<<<<<<<<<<< test 07-03-2018
!         if ((nlostp(ffj) == 1).or.(nlostp(ffj) == 2).or.(nlostp(ffj) == 11).or.                     &
!             (nlostp(ffj) == 19)) then
!           write(*,*) "124 421",p0,e0f,e0f*c1e3*c1e3/clight," dtl ",dpsv(ffj)," p0sp ",oidpsv(ffj), &
!                               " gam0 ",gamma0," ffj ",nlostp(ffj)
!         endif
!   <<<<<<<<<<<<<< test 07-03-2018
         
!       enddo
!     endif


   ! 3 : Allocation table for particles out of boundary
   ! -------------------------------------------------------------------------
   else if ((workChoise == 3)) then
      if (firstTime2) then
         ALLOCATE(ffloss(1:npart,1:numl,1:ffNLn,1:2),ffnotIN(1:npart,1:ffNLn))
         do i=1,npart
            do j=1,numl
               do k=1,ffNLn
                  ffloss(i,j,k,1)=0
                  ffloss(i,j,k,2)=0
               enddo
            enddo
         enddo

         do i=1,npart
            do k=1,ffNLn
               ffnotIN(i,k)=.false.
            enddo
         enddo

         firstTime2=.false.

      else
         write(*,*) 'FringeField ERROR: Allocation table for particles out of boundary already done!'
         return

      endif

      
   ! 2 : Symplectic routine
   ! -------------------------------------------------------------------------
   else if ((workChoise == 2).and.(.not.firstTime)) then
      if (.not.ffImported(dataindex)) then
         write (*, *) 'FringeField ERROR: The data in', ffFNames(dataindex) ,'is not imported'

      else
         ! Change to Symp referenciale

!write(*,*) "FField 1 -> ffj=",ffj," ffi=",ffi


!dpd(j)=0 !!!!
!         x = ((xv(1,ffj)-xsiv(1,ffi))*tiltc(ffi) + (xv(2,ffj)-zsiv(1,ffi))*tilts(ffi))*c1m3! mm -> m
!         y = ((xv(2,ffj)-zsiv(1,ffi))*tiltc(ffi) - (xv(1,ffj)-xsiv(1,ffi))*tilts(ffi))*c1m3! mm -> m
!         px= ((yv(1,ffj)            )*tiltc(ffi) + (yv(2,ffj)            )*tilts(ffi))*c1m3*dpd(ffj)
!         py= ((yv(2,ffj)            )*tiltc(ffi) - (yv(1,ffj)            )*tilts(ffi))*c1m3*dpd(ffj)


         x = ((xv(1,ffj)-xsiv(1,ffi))*tiltc(ffi) + (xv(2,ffj)-zsiv(1,ffi))*tilts(ffi))*c1m3! mm -> m
         y = ((xv(2,ffj)-zsiv(1,ffi))*tiltc(ffi) - (xv(1,ffj)-xsiv(1,ffi))*tilts(ffi))*c1m3! mm -> m
         px= ((yv(1,ffj)            )*tiltc(ffi) + (yv(2,ffj)            )*tilts(ffi))*c1m3*(1.0d0+dpsv(ffj)) !/oidpsv(ffj) !*(1.0d0+dpsv(ffj))
         py= ((yv(2,ffj)            )*tiltc(ffi) - (yv(1,ffj)            )*tilts(ffi))*c1m3*(1.0d0+dpsv(ffj)) !/oidpsv(ffj) !*(1.0d0+dpsv(ffj))


!With drift before
!         if (currQuad(2)==1) stracki = strack(ffi+1)*half
!         if (currQuad(2)==2) stracki = strack(ffi-1)*half
!         x = ((xv(1,ffj)-stracki*yv(1,ffj)-xsiv(1,ffi))*tiltc(ffi) &
!            + (xv(2,ffj)-stracki*yv(2,ffj)-zsiv(1,ffi))*tilts(ffi))*c1m3! mm -> m
!         y = ((xv(2,ffj)-stracki*yv(2,ffj)-zsiv(1,ffi))*tiltc(ffi) &
!            - (xv(1,ffj)-stracki*yv(1,ffj)-xsiv(1,ffi))*tilts(ffi))*c1m3! mm -> m
!         px= ((yv(1,ffj)                              )*tiltc(ffi) &
!            + (yv(2,ffj)                              )*tilts(ffi))*c1m3/oidpsv(ffj) !*(1.0d0+dpsv(ffj))
!         py= ((yv(2,ffj)                              )*tiltc(ffi) &
!            - (yv(1,ffj)                              )*tilts(ffi))*c1m3/oidpsv(ffj) !*(1.0d0+dpsv(ffj))
 
         zb= 0;
         delta= dpsv(ffj);
         gam0= gamma0;


!write(*,*) "FField 2 -> ffj=",ffj," ffi=",ffi,"   -> Enter!"


!         if (ffj==1) then
!            write(*,*) " "
!            write(*,*) "Before (in Interface1) : ffi= ", ffi, " ffj= ",ffj
!            write(*,*) "Before (in Interface1) : xv(1)= ", xv(1,ffj), " xv(2)= ",xv(2,ffj)
!            write(*,*) "Before (in Interface2) : x    = ", x        , " y    = ",y
!            write(*,*) "Before (in Interface1) : yv(1)= ", yv(1,ffj), " yv(2)= ",yv(2,ffj)
!            write(*,*) "Before (in Interface2) : px   = ", px       , " py   = ",py
!            write(*,*) "Before (in Interface1) : dpd(1)   = ",dpd(ffj)
!            write(*,*) "Before (in Interface1) : dpsv(1)  = ",dpsv(ffj)
!            write(*,*) "Before (in Interface1) : oidpsv(1)= ",oidpsv(ffj)
!            write(*,*) "Before (in Interface1) : tls= ", tilts(ffi), " tlc= ",tiltc(ffi)
!            write(*,*) "Before (in Interface2) : ejfv = ", ejfv(ffj), " ejf0v=", ejf0v(ffj) 
!            write(*,*) "Before x = ", x, " y= ",y
!            write(*,*) "File -> ",ffFNames(dataindex)
!         endif
         
         ! Generate the anti-quad
         if (ffTA(dataindex)%checkAQ(nlostp(ffj))) then
           call GenerateAntiQuad(oidpsv(ffj), &
                             ffTA(dataindex)%n,                   &
                             ffTA(dataindex)%m,                   &
                             ffTA(dataindex)%s,                   &
                             ffTA(dataindex)%dz,                  &
                             ffTA(dataindex)%lz,                  &
                             ffTA(dataindex)%ij_TAz,              &
                             ffTA(dataindex)%TAz,inex,            &
                             ffTA(dataindex)%AQx(1,1,nlostp(ffj)),&
                             ffTA(dataindex)%AQx(1,2,nlostp(ffj)),&
                             ffTA(dataindex)%AQx(2,1,nlostp(ffj)),&
                             ffTA(dataindex)%AQx(2,2,nlostp(ffj)),&
                             ffTA(dataindex)%AQy(1,1,nlostp(ffj)),&
                             ffTA(dataindex)%AQy(1,2,nlostp(ffj)),&
                             ffTA(dataindex)%AQy(2,1,nlostp(ffj)),&
                             ffTA(dataindex)%AQy(2,2,nlostp(ffj)))
           
           ffTA(dataindex)%checkAQ(nlostp(ffj))=.false.
         endif
         
         
         ! Selection of the particle that are only in the radius (r = 0.05m)
!         if ((x*x+y*y>2.5d-3).or.(pstop(nlostp(ffj)))) then
         if (((currQuad(2)==1).and.(x*x+y*y>3.6d-3)).or.             &!(x*x+y*y>2.5d-3)).or.             &
             ((currQuad(2)==2).and.(ffnotIN(nlostp(ffj),currQuad(1)))).or.       &
             (pstop(nlostp(ffj)))) then
!	   write(*,*) "FField Part ",ffj," out of trust area (el. ",currQuad(1),")"
         
            if (firstTime2) then
              write (*, *) "FringeField ERROR: The table for losses paticles wasn't allocated!"

            else
              ffloss(nlostp(ffj),ffn,currQuad(1),currQuad(2))=1 
              if (currQuad(2)==1) then
                ffnotIN(nlostp(ffj),currQuad(1)) = .true.
              else
                ffnotIN(nlostp(ffj),currQuad(1)) = .false.
              endif

            endif
         
	! Symplectic routine
         else
           if (currQuad(2)==1) inex = "IN"
           if (currQuad(2)==2) inex = "OUT"

  	   !   - Repositionnement initial
  	   if ((inex=="IN").or.(inex=="OUT_O")) then
             call AntiDriftAntiQuad(x,px,y,py, ffParam(dataindex,1),ffTA(dataindex)%Lgth,    &
                      ffParam(dataindex,2),ffParam(dataindex,3), ffParam(dataindex,4),       &
                      ffParam(dataindex,5),'D',oidpsv(ffj)) !,1.0d0/(1.0d0+delta))
   	   elseif (inex=="OUT") then
             ! First AntiQuad routine
!             call AntiDriftAntiQuad(x,px,y,py, ffParam(dataindex,1),ffTA(dataindex)%Lgth,    &
!                      ffParam(dataindex,2),ffParam(dataindex,3),ffParam(dataindex,4),        &
!                      ffParam(dataindex,5),'Q',oidpsv(ffj)) !,1.0d0/(1.0d0+delta))

             ! New AntiQuad routine
             x=x+(ffTA(dataindex)%Lgth-ffParam(dataindex,2))*oidpsv(ffj)*px;
             y=y+(ffTA(dataindex)%Lgth-ffParam(dataindex,2))*oidpsv(ffj)*py;
             call ComputeAntiQuad(x,px,y,py,                      &
                             ffTA(dataindex)%AQx(1,1,nlostp(ffj)),&
                             ffTA(dataindex)%AQx(1,2,nlostp(ffj)),&
                             ffTA(dataindex)%AQx(2,1,nlostp(ffj)),&
                             ffTA(dataindex)%AQx(2,2,nlostp(ffj)),&
                             ffTA(dataindex)%AQy(1,1,nlostp(ffj)),&
                             ffTA(dataindex)%AQy(1,2,nlostp(ffj)),&
                             ffTA(dataindex)%AQy(2,1,nlostp(ffj)),&
                             ffTA(dataindex)%AQy(2,2,nlostp(ffj)))
   	   endif

! <<<< to be clean
!open(88,file="temp6.log")
! <<<< to be clean
!write(88,*) "#ffj= ",ffj," Q= ",ffFNames(dataindex)

!write(*,*) "FField 3 -> ffj=",ffj," ffi=",ffi


 	   !   - Calcul du Fringe Field grace a la Map symplectique
           !call SympIntegrator(x,px,y,py,zb,delta,gam0, &
           call SympIntegrator(x,px,y,py,zb,oidpsv(ffj), &
                             ffTA(dataindex)%n,       &
                             ffTA(dataindex)%m,       &
                             ffTA(dataindex)%s,       &
                             ffTA(dataindex)%dz,      &
                             ffTA(dataindex)%lx,      &
                             ffTA(dataindex)%ij_TAx,  &
                             ffTA(dataindex)%TAx,     &
                             ffTA(dataindex)%ly,      &
                             ffTA(dataindex)%ij_TAy,  &
                             ffTA(dataindex)%TAy,     & 
                             ffTA(dataindex)%lz,      &
                             ffTA(dataindex)%ij_TAz,  &
                             ffTA(dataindex)%TAz,     &
                             inex)

! <<<< to be clean
!close(88)
! <<<< to be clean


!write(*,*) "FField 4 -> ffj=",ffj," ffi=",ffi

  	   !   - Repositionnement Final
   	   if ((inex=="IN").or.(inex=="OUT_O")) then
             ! First AntiQuad routine
!             call AntiDriftAntiQuad(x,px,y,py, ffParam(dataindex,1),ffTA(dataindex)%Lgth,    &
!                      ffParam(dataindex,2),ffParam(dataindex,3),ffParam(dataindex,4),        &
!                      ffParam(dataindex,5),'Q',oidpsv(ffj)) !,1.0d0/(1.0d0+delta))

             ! New AntiQuad routine
             call ComputeAntiQuad(x,px,y,py,                      &
                             ffTA(dataindex)%AQx(1,1,nlostp(ffj)),&
                             ffTA(dataindex)%AQx(1,2,nlostp(ffj)),&
                             ffTA(dataindex)%AQx(2,1,nlostp(ffj)),&
                             ffTA(dataindex)%AQx(2,2,nlostp(ffj)),&
                             ffTA(dataindex)%AQy(1,1,nlostp(ffj)),&
                             ffTA(dataindex)%AQy(1,2,nlostp(ffj)),&
                             ffTA(dataindex)%AQy(2,1,nlostp(ffj)),&
                             ffTA(dataindex)%AQy(2,2,nlostp(ffj)))
             x=x+(ffTA(dataindex)%Lgth-ffParam(dataindex,2))*oidpsv(ffj)*px;
             y=y+(ffTA(dataindex)%Lgth-ffParam(dataindex,2))*oidpsv(ffj)*py;
             
  	   elseif (inex=="OUT") then
             call AntiDriftAntiQuad(x,px,y,py, ffParam(dataindex,1),ffTA(dataindex)%Lgth,    &
                      ffParam(dataindex,2),ffParam(dataindex,3),ffParam(dataindex,4),        &
                      ffParam(dataindex,5),'D',oidpsv(ffj)) !,1.0d0/(1.0d0+delta))
   	   endif


!write(*,*) "FField 5 -> oidpsv(ffj)=",oidpsv(ffj)," / ",1d0/(1d0+dpsv(ffj))
!write(*,*) "FField 5 -> ffj=",ffj," ffi=",ffi

            ! Change to SixTrack referenciale
            yv(1,ffj) = (tiltc(ffi)*px - tilts(ffi)*py)*c1e3*oidpsv(ffj) !/(1.0d0+dpsv(ffj))
            yv(2,ffj) = (tilts(ffi)*px + tiltc(ffi)*py)*c1e3*oidpsv(ffj) !/(1.0d0+dpsv(ffj))
            xv(1,ffj) = (tiltc(ffi)*x  - tilts(ffi)*y )*c1e3 + xsiv(1,ffi)!+stracki*yv(1,ffj)   ! m -> mm
            xv(2,ffj) = (tilts(ffi)*x  + tiltc(ffi)*y )*c1e3 + zsiv(1,ffi)!+stracki*yv(2,ffj)   ! m -> mm


!write(*,*) "FField 6 -> ffj=",ffj," ffi=",ffi,"   -> Exit!"


!            if (ffj==1) then
!               write(*,*) "Before (in Interface1) : ffi= ", ffi, " ffj= ",ffj
!               write(*,*) "After (in Interface1) : xv(1)= ", xv(1,ffj), " xv(2)= ",xv(2,ffj)
!               write(*,*) "After (in Interface2) : x    = ", x        , " y    = ",y
!               write(*,*) "After (in Interface1) : yv(1)= ", yv(1,ffj), " yv(2)= ",yv(2,ffj)
!               write(*,*) "After (in Interface2) : px   = ", px       , " py   = ",py
!               write(*,*) "After (in Interface1) : tls= ", tilts(ffi), " tlc= ",tiltc(ffi)
!               write(*,*) "After (in Interface1) : xsv= ", xsiv(1,ffi),  " zsv= ",zsiv(1,ffi)
!               write(*,*) "After (in Interface2) : ejfv = ", ejfv(ffj), " ejf0v=", ejf0v(ffj)
!               write(*,*) "After x = ", x, " y= ",y
!            endif
	endif
      endif
      
      
   ! 6 : End of the code -> free the memory
   ! -------------------------------------------------------------------------
   else if (workChoise == 6) then
      write(*,*) " "
      write(*,*) "------------------------ Fringe Field end ------------------------"


      if (.not.firstTime2) then
!         if (.not.firstTime) then
!            do i = 1,npart
!               if (pstop(i)) then
!                  write(*,*) "     * Part ",i,":    LOST!!!"
!               else
!                  write(*,*) "     * Part ",i,":"
!               endif
!
!               do k = 1,ffNLn
!                  sum_loss_in=0
!                  sum_loss_out=0
!                  do j = 1,numl
!                     sum_loss_in =sum_loss_in +ffloss(i,j,k,1)
!                     sum_loss_out=sum_loss_out+ffloss(i,j,k,2)
!                  enddo
!            
!                  write(*,*) "           -> ",ffQNames(k),": Number of period out of boundary: (in) ",&
!                         &sum_loss_in," (out) ",sum_loss_out
!               enddo
!            enddo
!         endif
         deallocate(ffloss,ffnotIN)
         firstTime2 = .true.
         write (*,*) "FringeField : Table for particle out of boundary deallocated!"

      else
         write (*,*) "FringeField : Table for particle out of boundary wasn't deallocated!"

      endif



      if (.not.firstTime) then
         do i = 1,ffNLFile
            if (ffImported(i)) then
               deallocate(ffTA(i)%ij_TAx, ffTA(i)%ij_TAy, ffTA(i)%ij_TAz )
               deallocate(ffTA(i)%TAx   , ffTA(i)%TAy   , ffTA(i)%TAz    )
               deallocate(ffTA(i)%AQx   , ffTA(i)%AQy   , ffTA(i)%checkAQ)
            endif
         enddo
         deallocate (ffTA)
         deallocate (ffImported)
         deallocate (ffQNames, ffParam)
         ffQNames => NULL()
         ffParam => NULL()
         firstTime = .true.
         write (*,*) "FringeField : All Fringe-Field table's deallocated!"

      else
         write (*,*) "FringeField : All Fringe-Field table's weren't deallocated!"

      endif
   
   else
      write(*,*) 'FringeField ERROR: Not valid choise ', workChoise, ' or empty tables >> ', firstTime
      write(*,*) '                   CurQ = ',currQuad(1),currQuad(2)
      write(*,*) '                   ffQ2File = ',ffQ2File(currQuad(1),currQuad(2)),' Id Tab = ', dataindex

   endif
   
   return
end subroutine




!! ---------------------------------------------------------------------------
!!      Routine to test the code
!! ---------------------------------------------------------------------------
subroutine fftest(n,m,s,dz,Lgth,lx,ij_TAx,TAx,ly,ij_TAy,TAy,lz,ij_TAz,TAz,norm)
     integer :: n,m,s                                                      ! Exposant maximum pour x et y, Nombre de point en z
     integer :: lx,ly,lz                                                   ! 
     integer(kind=2),dimension(:,:,:), allocatable :: ij_TAx,ij_TAy,ij_TAz  ! Tableau des indices ij de Ax, Ay et Az
     double precision :: dz,norm,Lgth                                          ! Taille du pas en z et normalisation
     double precision,dimension(:,:), allocatable :: TAx,TAy,TAz            ! Nouveau tableau des coefficients de Ax, Ay et Az
     

     n = 3
     m = 12
     s = 12122
     dz = 0.256
     Lgth = 0.1
     lx = 223
     ly = 225
     lz = 224

     allocate(ij_TAx(1:2,1:2,1:3), ij_TAz(1:2,1:2,1:3), ij_TAy(1:2,1:2,1:3))
     allocate(TAx(1:2,1:2), TAz(1:2,1:2), TAy(1:2,1:2))

     ij_TAx(1:2,1:2,1:3) = 1
     TAx(1:2,1:2) = 2
     ij_TAy(1:2,1:2,1:3) = 3
     TAy(1:2,1:2) = 4
     ij_TAz(1:2,1:2,1:3) = 5
     TAz(1:2,1:2) = 9
     norm = 0.288
end subroutine
+ei
