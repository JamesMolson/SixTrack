+dk ffsympintegrator
+if ffield
!! ---------------------------------------------------------------------------
!!      Subroutine de la MAJ du point (x,y,z,px,py,delta)
!! ---------------------------------------------------------------------------
subroutine SympIntegrator(x,px,y,py,zb,delta,gam0,n,m,s,dz,lx,ij_Ax,TAx,ly,ij_Ay,TAy,lz,ij_Az,TAz,inex)
   implicit none

   ! Initialisation des parametres
   ! -------------------------------------------------------------------------
   character(len=512) :: inex           ! Characterise si on est en entree ou en sortie
   integer :: i                         ! Indice de la boucle pour la position z
   integer :: n,m,s                     ! Expo. max pour x et y, et Nb de pas en z
   integer :: lx,ly,lz
   integer :: startp,endp,sens
   integer(kind=2) :: ij_Ax(0:1,0:lx,0:s),ij_Ay(0:1,0:ly,0:s),ij_Az(0:1,0:lz,0:s)
   double precision :: x, y, zb         ! Position initial x, y et curviligne z
   double precision :: px, py, delta    ! Impulsion initial
   double precision :: dz, gam0         ! Pas en z et coefficient gam0
   double precision :: valA             ! Coefficient de MAJ donne par la subroutine
!   double precision :: g2d2inv
   double precision :: dzover2          !  Dsigma/2
   double precision :: deltap1
   !double precision :: TAx(0:lx,0:s+1),TAy(0:ly,0:s+1),TAz(0:lz,0:s+1)
   double precision :: TAx(0:lx,0:s),TAy(0:ly,0:s),TAz(0:lz,0:s)
   
   
   ! Initialisation de la taille des pas en z
   ! -------------------------------------------------------------------------
   dzover2=0.5d0*dz !loc

   ! Calcul de deltap1 = 1/(1+delta)
   ! -------------------------------------------------------------------------
   deltap1=1.0d0/(1.0d0+delta)

   !                    ?????????????????????????????????
   ! -------------------------------------------------------------------------
!   g2d2inv=deltap1/gam0
!   g2d2inv=g2d2inv*g2d2inv*0.5d0
   
   
   ! Boucle en z
   ! -------------------------------------------------------------------------
   ! >>>>>>>>>>>>>>>>>>>>>>>>>>>>> Rajouter pour inverser la lecture des tableaux
   startp = 0
   endp = s-1
!   endp = s
   sens = 1


   if (inex=="OUT_O") then
      startp = endp
      endp = 0
      sens = -1
      dz=-dz
      dzover2=-dzover2
   endif
   ! <<<<<<<<<<<<<<<<<<<<<<<<<<<<< Rajouter pour inverser la lecture des tableaux

   do i=startp,endp,sens
      !             * h1
!      zb=zb-dzover2*g2d2inv                                    ! ???????????

      !             * h2
      call HornerDX(x, y, i, n, m, s, lz, ij_Az, TAz, valA)
      px=px+dzover2*valA
      call HornerDY(x, y, i, n, m, s, lz, ij_Az, TAz, valA)
      py=py+dzover2*valA

      !             * h3
      !                 ** Changement de variable
      call Horner2D(x, y, i, n, m, s, lx, ij_Ax, TAx, valA)
      px=px-valA
      call HornerDYIntX(x, y, i, n, m, s, lx, ij_Ax, TAx, valA)
      py=py-valA

      x=x+dzover2*px*deltap1
 !     zb=zb-dzover2*0.5d0*px*px*deltap1*deltap1

      !call Horner2D(x, y, i, n, m, s, ly, ij_Ay, TAy, valA)
      !py=py-valA
      !call HornerDXIntY(x, y, i, n, m, s, ly, ij_Ay, TAy, valA)
      !px=px-valA

      !y=y+dzover2*py*deltap1
!      zb=zb-dzover2*0.5d0*py*py*deltap1*deltap1


      !                 ** Changement de variable
      call Horner2D(x, y, i, n, m, s, lx, ij_Ax, TAx, valA)
      px=px+valA
      call HornerDYIntX(x, y, i, n, m, s, lx, ij_Ax, TAx, valA)
      py=py+valA

      !call Horner2D(x, y, i, n, m, s, ly, ij_Ay, TAy, valA)
      !py=py+valA
      !call HornerDXIntY(x, y, i, n, m, s, ly, ij_Ay, TAy, valA)
      !px=px+valA


      !             * h4
      !                 ** Changement de variable
      call HornerDXIntY(x, y, i, n, m, s, ly, ij_Ay, TAy, valA)
      px=px-valA
      call Horner2D(x, y, i, n, m, s, ly, ij_Ay, TAy, valA)
      py=py-valA

      y=y+dz*py*deltap1
      !zb=zb-dzover2*py*py*deltap1*deltap1

      !call HornerDYIntX(x, y, i, n, m, s, lx, ij_Ax, TAx, valA)
      !py=py-valA
      !call Horner2D(x, y, i, n, m, s, lx, ij_Ax, TAx, valA)
      !px=px-valA

      !x=x+dz*px*deltap1
!      zb=zb-dzover2*px*px*deltap1*deltap1


      !                 ** Changement de variable
      call HornerDXIntY(x, y, i, n, m, s, ly, ij_Ay, TAy, valA)
      px=px+valA
      call Horner2D(x, y, i, n, m, s, ly, ij_Ay, TAy, valA)
      py=py+valA

      !call HornerDYIntX(x, y, i, n, m, s, lx, ij_Ax, TAx, valA)
      !py=py+valA
      !call Horner2D(x, y, i, n, m, s, lx, ij_Ax, TAx, valA)
      !px=px+valA


      !             * h3
      !                 ** Changement de variable
      call Horner2D(x, y, i, n, m, s, lx, ij_Ax, TAx, valA)
      px=px-valA
      call HornerDYIntX(x, y, i, n, m, s, lx, ij_Ax, TAx, valA)
      py=py-valA

      x=x+dzover2*px*deltap1
      !zb=zb-dzover2*0.5d0*px*px*deltap1*deltap1

      !call Horner2D(x, y, i, n, m, s, ly, ij_Ay, TAy, valA)
      !py=py-valA
      !call HornerDXIntY(x, y, i, n, m, s, ly, ij_Ay, TAy, valA)
      !px=px-valA

      !y=y+dzover2*py*deltap1
 !     zb=zb-dzover2*0.5d0*py*py*deltap1*deltap1


      !                 ** Changement de variable
      call Horner2D(x, y, i, n, m, s, lx, ij_Ax, TAx, valA)
      px=px+valA
      call HornerDYIntX(x, y, i, n, m, s, lx, ij_Ax, TAx, valA)
      py=py+valA

      !call Horner2D(x, y, i, n, m, s, ly, ij_Ay, TAy, valA)
      !py=py+valA
      !call HornerDXIntY(x, y, i, n, m, s, ly, ij_Ay, TAy, valA)
      !px=px+valA


      !             * h2
      call HornerDX(x, y, i, n, m, s, lz, ij_Az, TAz, valA)
      px=px+dzover2*valA
      call HornerDY(x, y, i, n, m, s, lz, ij_Az, TAz, valA)
      py=py+dzover2*valA

      !             * h1
!      zb=zb-dzover2*g2d2inv                                    ! ??????????
   enddo
end subroutine


!! ---------------------------------------------------------------------------
!!      Calcul de l'anti-Drift ou de l'anti-Quad suivant oper
!! ---------------------------------------------------------------------------
subroutine AntiDriftAntiQuad(x,px,y,py,K,Lff,Lin,Corx,Cory,CoK,oper,deltap1)
   implicit none

   ! Initialisation des parametres
   ! -------------------------------------------------------------------------
   character :: oper                  ! Operation a effectuer ("AD" pour anti-
                                      ! Drift, "AQ" pour anti-Quad)
   double precision :: x, y           ! Position initial x, y
   double precision :: px, py         ! Impulsion initial
   double precision :: x_tmp, y_tmp   ! Position initial x, y temporaire
   double precision :: px_tmp, py_tmp ! Impulsion initial temporaire
   double precision :: K              ! Force de l'anti-Quad
   double precision :: Lff,Lin,Lin_tp ! Longeur du fichier dans le Quad
   double precision :: deltap1
   double precision :: Corx, Cory, CoK!       et correcteur
   double precision :: Corx_tp, Cory_tp!       et correcteur
   double precision :: a,b,c,d,bcmad  ! Parametre pour le calcul de l'anti-Quad
   integer          :: NbDivQad=16, i  ! Nombre de Subdivision de l'anti-Quad
   double precision :: DbNbDivQad

   if (oper=="D") then       ! [D(Lff-Lin)]^-1
      x_tmp = x - (Lff-Lin)*px*deltap1
      y_tmp = y - (Lff-Lin)*py*deltap1
      px_tmp = px
      py_tmp = py


   elseif (oper=="Q") then   ! [D(-Cor/2)*Q(KLin,Lin+Cor)*D(-Cor/2)]^-1
      DbNbDivQad = dble(NbDivQad)
      Lin_tp  = Lin /DbNbDivQad
      Corx_tp = Corx/DbNbDivQad
      Cory_tp = Cory/DbNbDivQad
      
      ! Focalisation en x
      a =  1.0d0 - (K - CoK)*(Lin_tp+Corx_tp)* Lin_tp         *0.5d0 *deltap1
      b = (1.0d0 - (K - CoK)*(Lin_tp+Corx_tp)*(Lin_tp-Corx_tp)*0.25d0*deltap1)*Lin_tp*deltap1
      c =        - (K - CoK)* Lin_tp
      d =  1.0d0 - (K - CoK)*(Lin_tp-Corx_tp)* Lin_tp         *0.5d0 *deltap1
      !bcmad = a*d - b*c
      
      do i = 1,NbDivQad 
        x_tmp  = (d*x -b*px)!/bcmad
        px_tmp = (a*px -c*x)!/bcmad
        
        x  =  x_tmp
        px = px_tmp
      enddo

      ! Defocalisation en y
      a =  1.0d0 + (K + CoK)*(Lin_tp+Cory_tp)* Lin_tp         *0.5d0 *deltap1
      b = (1.0d0 + (K + CoK)*(Lin_tp+Cory_tp)*(Lin_tp-Cory_tp)*0.25d0*deltap1)*Lin_tp*deltap1
      c =          (K + CoK)* Lin_tp
      d =  1.0d0 + (K + CoK)*(Lin_tp-Cory_tp)* Lin_tp         *0.5d0 *deltap1
      !bcmad = a*d-b*c

      do i = 1,NbDivQad 
         y_tmp  = (d*y -b*py)!/bcmad
         py_tmp = (a*py -c*y)!/bcmad
        
         y  =  y_tmp
         py = py_tmp
      enddo

   else
      x_tmp  = x
      y_tmp  = y
      px_tmp = px
      py_tmp = py


   endif
   x  =  x_tmp
   y  =  y_tmp
   px = px_tmp
   py = py_tmp
end subroutine
+ei
