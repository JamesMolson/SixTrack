+dk fffileread
+if ffield
!! ---------------------------------------------------------------------------
!!      Read config file
!! ---------------------------------------------------------------------------
subroutine ReadconfigFile
   implicit none

   
   ! Initialisation common space with SixTrack
   ! -------------------------------------------------------------------------
+ca parpro

+ca ffieldcommon

+ca ffieldcommon1


   ! Initialisation of parametters
   ! -------------------------------------------------------------------------
   logical :: conti = .true.
   integer :: istat                                       ! Check accecibility of file
   integer :: i, id
   character(len=40) :: word 
   character(len=150) :: path
!   character(len=150) :: file_tm
   

   ! Find the file path
   ! -------------------------------------------------------------------------
   call getenv('FFConfigPath', path)
   
   if (path == " ") then
      write(*, *) "FringeField WARNING: Couldn't read the environment variable 'FFConfigPath'"
!      path ='/afs/cern.ch/user/d/dalena/hllhc/'
      path ='./'
      write(*, *) "                     we look for 'configFringeField.txt' in ", TRIM(ADJUSTL(path))
   endif


   ! Open the file
   ! -------------------------------------------------------------------------
   istat=0
   ffNLn=0
   ffNLFile=0
   open(1789,file=TRIM(ADJUSTL(path))//'/configFringeField.txt',form='formatted',status='old',iostat=istat)
   if (istat/=0) then
      write(*,*) "FringeField ERROR: Couldn't find the configuration file configFringeField.txt" 
      write(*,*) "FringeField ERROR: in ",TRIM(ADJUSTL(path))
   else
      ! Counting the line in the first part of the file
      ! -------------------------------------------------------------------------
      read(1789,*,iostat=istat) word           !skip the first line
      if ((word == "NEXT").or.(word == "END")) then
         write(*,*) 'FringeField ERROR: Wrong format config file'
         return
      endif

      read(1789,*,iostat=istat) word           !skip the second line
      if ((word == "NEXT").or.(word == "END")) then
         write(*,*) 'FringeField ERROR: Wrong format config file'
         return
      endif

      do while((istat==0).and.(conti))    !start reading   
         read(1789,*,iostat=istat) word
         if (word=="NEXT") then
            conti=.false.
         else
            ffNLn=ffNLn+1
         endif
      end do

      ! Counting the line in the second part of the file
      ! -------------------------------------------------------------------------
      conti = .true.

      read(1789,*,iostat=istat) word           !skip the first line
      if ((word == "NEXT").or.(word == "END")) then
         write(*,*) 'FringeField ERROR: Wrong format config file'
         return
      endif

      do while((istat==0).and.(conti))    !start reading       
         read(1789,*,iostat=istat) word
         if (word=="END") then
            conti=.false.
         endif
         ffNLFile=ffNLFile+1 
      end do

      close(1789)
      if ((ffNLn < 1).or.(ffNLFile < 1)) then
         write(*,*) "FringeField ERROR: The configuration file configFringeField.txt has only ",ffNLn," and ", ffNLFile,"lines" 
      else
         allocate(ffQNames(1:ffNLn), ffFNames(1:ffNLFile), ffParam(1:ffNLFile,1:6), ffQ2File(1:ffNLn, 1:2))
         ffQNames = " "
         ffFNames = " "
         ffParam  = 0.0d0
         ffQ2File  = 0
         open(1789,file=TRIM(ADJUSTL(path))//'configFringeField.txt',form='formatted',status='old',iostat=istat)
         
         !Read the first part
         read(1789,*,iostat=istat)
         read(1789,*,iostat=istat)

         do i=1,ffNLn
            !                         Quad name   ,File in       ,File out
            read(1789,*,iostat=istat) ffQNames(i), ffQ2File(i,1), ffQ2File(i,2)
         enddo
         
         !Read the second part
         read(1789,*,iostat=istat)
         read(1789,*,iostat=istat)

         do i=1,ffNLFile
            !                         Filename   ,K0          ,LinQ        ,Corr. x     ,Corr. y     ,Corr. K     ,Length File
            read(1789,*,iostat=istat) ffFNames(i),ffParam(i,1),ffParam(i,2),ffParam(i,3),ffParam(i,4),ffParam(i,5),ffParam(i,6)
!            read(1789,*,iostat=istat) file_tm,ffParam(i,1),ffParam(i,2),ffParam(i,3),ffParam(i,4),ffParam(i,5),ffParam(i,6)
!            ffFNames(i)=TRIM(ADJUSTL(path))//TRIM(ADJUSTL(file_tm))
         enddo

         !check inputs
         do i = 1,ffNLn
            do id = 1,2
               if ((ffQ2File(i,id) > ffNLFile).or.(ffQ2File(i,id) < 1)) then
                  write(*,*) "FringeField ERROR: In the configuration file, file name reference is bad"
                  return
               endif
            enddo
         enddo

         write(*,*) "FringeField      : SUCCESS!!!!!!!!!"
         ffReady = .true.
         close(1789)
      endif
   endif
end subroutine




!! ---------------------------------------------------------------------------
!!      Subroutine creating the vector potential tables
!! ---------------------------------------------------------------------------
subroutine CreateVectCoef(FileName,n,m,s,dz,Lgth,linex,ij_TAx,TAx,liney,ij_TAy,TAy,linez,ij_TAz,TAz,norm,OKRead)


   ! Initialisation of the parametters
   ! -------------------------------------------------------------------------
   character(len=*) :: FileName                                         ! File adress
   logical :: OKRead                                                    ! Error
   integer :: n,m,s                                                     ! Maximum exposant for x and y, Number of point in z
   integer :: linex,liney,linez                                         ! Number of coefficient by point
   integer(kind=2),dimension(:,:,:),allocatable :: ij_TAx,ij_TAy,ij_TAz ! Table of indices ij for Ax, Ay et Az
   double precision :: dz, norm,Lgth                                    ! Step size in z and normalisation
   double precision,dimension(:,:),allocatable :: TAx,TAy,TAz           ! New table for coefficients of Ax, Ay et Az

   interface
      subroutine ReadVectPotCoeff(FileName,n,m,s,dz,Lgth,linex,ij_TAx,TAx,liney,ij_TAy,TAy,linez,ij_TAz,TAz,norm,OKRead)
         character(len=*) :: FileName
         logical :: OKRead
         integer :: n,m,s
         integer :: linex,liney,linez
         integer(kind=2),dimension(:,:,:),allocatable :: ij_TAx, ij_TAy, ij_TAz
         double precision :: dz, norm,Lgth
         double precision,dimension(:,:),allocatable :: TAx, TAy, TAz
      end subroutine
   end interface


   ! Detect the mamixum exposant for x and y, and the number of point in z
   ! -------------------------------------------------------------------------
   call ReadExpMax(FileName, n, m, s, OKRead)

   if (.not.OKRead) then
      stop
   endif


   ! Generate the vecto potential table
   ! -------------------------------------------------------------------------
   call ReadVectPotCoeff(FileName,n,m,s,dz,Lgth, linex,ij_TAx,TAx, liney,ij_TAy,TAy, linez,ij_TAz,TAz, norm,OKRead)
end subroutine




!! ---------------------------------------------------------------------------
!!      Subroutine that detect the max expo. of x and y and the nb of step in z
!! ---------------------------------------------------------------------------
subroutine ReadExpMax(FileName, n, m, s, OKRead)


   ! Initialisation of parametters
   ! -------------------------------------------------------------------------
   !character(*), PARAMETER :: fileplace = "/afs/cern.ch/user/d/dalena/hllhc/" 
   character(len=*) :: FileName                                               ! File Adress
   logical :: OKRead                                                          ! Error
   integer :: istat                                                           ! Check. accecibility of the file
   integer :: line                                                            ! Nb of line in file
   integer :: n,m,s                                                           ! Exposant max for x and y, Nb of point in z
   integer :: expx,expy,expz                                                  ! Expo. for x, y and z
   integer, parameter :: lun=10                                               ! 
   double precision :: st, sm1                                                ! Parametter for the detection of new step in z


   ! Check the file exist
   ! -------------------------------------------------------------------------
   istat=0
   open(unit=lun,iostat=istat,file=TRIM(ADJUSTL(FileName)),STATUS='OLD')
   if (istat/=0) then
      write(*,*) "FringeField ERROR: Opening Error ", FileName
      stop
   endif


   ! Initialize values
   ! -------------------------------------------------------------------------
   istat=0
   n=0
   m=0
   st=0.
   sm1=1e12
   line=1
   s=0
   

   ! Read file
   ! -------------------------------------------------------------------------
   do while(istat==0)
      read(lun,*,iostat=istat) st, expx, expy, expz ! Read line
      if (st>sm1+1e-12) then                        ! Detect new step in z
         s = s + 1                                  ! Compte step in z
      endif
      if (expx>n) n=expx                            ! Max. expo. in x
      if (expy>m) m=expy                            ! Max. expo. in y
      sm1=st
      line=line+1                                   ! File size
   end do


   ! Close file
   ! -------------------------------------------------------------------------
   close(lun)
   OKRead=.True.
   return
end subroutine




!! ---------------------------------------------------------------------------
!!      Subroutine that generate the vector potential tables
!! ---------------------------------------------------------------------------
subroutine ReadVectPotCoeff(FileName,n,m,s,dz,Lgth, linex,ij_TAx,TAx, liney,ij_TAy,TAy, linez,ij_TAz,TAz, norm,OKRead)


   ! Initialization of parametters
   ! -------------------------------------------------------------------------
   !character(*), PARAMETER :: fileplace = "/afs/cern.ch/user/d/dalena/hllhc/" 
   character(len=*) :: FileName                                             ! File adress
   logical :: CoefSave                                                      ! 
   logical :: OKRead                                                        ! Error
   integer :: istat                                                         ! Check file accecibility
   integer :: k,l                                                           ! Line for the table x, y and z
   integer :: n,m,s                                                         ! Max. expo. for x and y, Number of point in z
   integer :: expx,expy,expz                                                ! Expo. of x, y and z
   integer :: sline                                                         ! Line in z
   integer :: ind,alloc_stat
   integer :: linex,liney,linez,tlinex,tliney,tlinez                        ! 
   integer, parameter :: lun=10                                             ! 
   integer(kind=2),dimension(:,:,:),allocatable :: ij_TAx, ij_TAy, ij_TAz   ! Table of indices ij for Ax, Ay et Az
   integer(kind=2),dimension(:,:,:),allocatable :: tpij_Ax, tpij_Ay, tpij_Az! Temporary table of indices ij for Ax, Ay et Az
   double precision :: ax, ay, az                                           ! Coef. values
   double precision :: st, sm1                                              ! Parametter for step size detection z
   double precision :: dz, norm                                             ! Step size in z and normalization
   double precision :: zin, Lgth
   double precision,dimension(:,:),allocatable :: TAx, TAy, TAz             ! New table for coefficients of Ax, Ay and Az
   double precision,dimension(:,:),allocatable :: tpTAx, tpTAy, tpTAz       ! Temporary table for coeff. of Ax, Ay and Az


   ! Allocation of memory for tables
   ! -------------------------------------------------------------------------
   ind= n*m/2
   ALLOCATE(tpTAx(0:ind,0:s),tpTAy(0:ind,0:s),tpTAz(0:ind,0:s), stat = alloc_stat)
   if (alloc_stat/=0) then
      write(*,*) "FringeField ERROR: Error allocate Tab FileRead"
      return
   endif                                            ! (line,z)
   ALLOCATE(tpij_Ax(0:1,0:ind,0:s),tpij_Ay(0:1,0:ind,0:s),tpij_Az(0:1,0:ind,0:s), stat = alloc_stat)
   if (alloc_stat/=0) then
      write(*,*) "FringeField ERROR: Error allocate Tab FileRead"
      return
   endif                                            ! (0 pour i et 1 pour j,line,z)
   

   linex=0;liney=0;linez=0
   do k=0,s
      ! Initialize tables
      ! -------------------------------------------------------------------------
      do l=0,ind
            tpTAx(l,k)=0.0d0
            tpTAy(l,k)=0.0d0
            tpTAz(l,k)=0.0d0
            tpij_Ax(0,l,k)=0 ;tpij_Ax(1,l,k)=0 
            tpij_Ay(0,l,k)=0 ;tpij_Ay(1,l,k)=0 
            tpij_Az(0,l,k)=0 ;tpij_Az(1,l,k)=0 
      enddo
   enddo

   ! Check file exist
   ! -------------------------------------------------------------------------
   istat=0
   open(unit=lun,iostat=istat,file=TRIM(ADJUSTL(FileName)),STATUS='OLD')
   if (istat/=0) then
      write(6,*) "FringeField ERROR: Opening Error ", FileName
      OKRead=.False.
      stop
   endif

   ! Initialize parameters
   ! -------------------------------------------------------------------------
   st=0.
   sm1=1e+12
   istat=0
   sline=0
   dz=0


   ! Read coef file
   ! -------------------------------------------------------------------------
   tlinex=0; tliney=0; tlinez=0
   do while(istat==0)
      st=0.0d0; expx=0; expy=0; expz=0; ax=0.0d0; ay=0.0d0; az=0.0d0; 
      read(lun,*,iostat=istat) st, expx, expy, expz, ax, ay, az              ! Read line


      if (st>sm1+1e-12) then                                                 ! Detect stepin z
         dz=dz+st-sm1
         sline = sline + 1
         tlinex=0; tliney=0; tlinez=0
      endif
      if (sline == 0) zin = st
      
      ! --------------- Detect coef non trivial for Ax ---------------
      if (ax/=0.) then
         CoefSave=.False.

         if (tlinex/=0) then
            do l=0,tlinex               ! Check coef already saved
               if ((tpij_Ax(0,l,sline)==INT2(expx)).AND.(tpij_Ax(1,l,sline)==INT2(expy))) then
                  tpTAx(l,sline)=tpTAx(l,sline) + ax
                  CoefSave=.True.
               endif
            enddo
         endif

         if (CoefSave.eqv..False.) then ! Create new coef

            tpij_Ax(0,tlinex,sline)=INT2(expx)
            tpij_Ax(1,tlinex,sline)=INT2(expy)
            tpTAx(tlinex,sline)=tpTAx(tlinex,sline) + ax
            tlinex=tlinex+1
            CoefSave=.True.
         endif
      endif

      ! --------------- Detect coef non trivial for Ay ---------------
      if (ay/=0.) then
         CoefSave=.False.

         if (tliney/=0) then
            do l=0,tliney               ! Check coef already saved
               if ((tpij_Ay(0,l,sline)==INT2(expx)).AND.(tpij_Ay(1,l,sline)==INT2(expy))) then
                  tpTAy(l,sline)=tpTAy(l,sline) + ay
                  CoefSave=.True.
               endif
            enddo
         endif

         if (CoefSave.eqv..False.) then ! Create new coef
            tpij_Ay(0,tliney,sline)=INT2(expx)
            tpij_Ay(1,tliney,sline)=INT2(expy)
            tpTAy(tliney,sline)=tpTAy(tliney,sline) + ay
            tliney=tliney+1
            CoefSave=.True.
         endif
      endif

      ! --------------- Detect coef non trivial for Az ---------------
      if (az/=0.) then
         CoefSave=.False.

         if (tlinez/=0) then
            do l=0,tlinez               ! Check coef already saved
               if ((tpij_Az(0,l,sline)==INT2(expx)).AND.(tpij_Az(1,l,sline)==INT2(expy))) then
                  tpTAz(l,sline)=tpTAz(l,sline) + az
                  CoefSave=.True.
               endif
            enddo
         endif

         if (CoefSave.eqv..False.) then ! Create new coef
            tpij_Az(0,tlinez,sline)=INT2(expx)
            tpij_Az(1,tlinez,sline)=INT2(expy)
            tpTAz(tlinez,sline)=tpTAz(tlinez,sline) + az
            tlinez=tlinez+1
            CoefSave=.True.
         endif
      endif


      ! Update tables size
      ! -------------------------------------------------------------------------
      if (linex<tlinex-1) then
         linex=tlinex-1
      endif
      if (liney<tliney-1) then
         liney=tliney-1
      endif
      if (linez<tlinez-1) then
         linez=tlinez-1
      endif

      if (istat==0) then
         sm1=st
      endif
      if (sline>s) then                                                      ! Detect error in z
         OKRead=.False.
         stop
      endif
   enddo
   !Lgth = st - zin
   Lgth = sm1 - zin


   ! Normalize coefficients
   ! -------------------------------------------------------------------------
   do k=0,s
      do l=0,linex
         tpTAx(l,k)=tpTAx(l,k)*norm
      enddo
   enddo
   do k=0,s
      do l=0,liney
         tpTAy(l,k)=tpTAy(l,k)*norm
      enddo
   enddo
   do k=0,s
      do l=0,linez
         tpTAz(l,k)=tpTAz(l,k)*norm
      enddo
   enddo
   dz=dz/dble(sline)
!   Lgth = Lgth + dz   

   ! Reduce table size
   ! -------------------------------------------------------------------------
   ALLOCATE(TAx(0:linex,0:s),TAy(0:liney,0:s),TAz(0:linez,0:s))                     ! (z,line)
   ALLOCATE(ij_TAx(0:1,0:linex,0:s),ij_TAy(0:1,0:liney,0:s),ij_TAz(0:1,0:linez,0:s))! (z,line,0 pour i et 1 pour j)
   
   TAx(0:linex,0:s)=tpTAx(0:linex,0:s); ij_TAx(:,0:linex,0:s)=tpij_Ax(:,0:linex,0:s)
   TAy(0:liney,0:s)=tpTAy(0:liney,0:s); ij_TAy(:,0:liney,0:s)=tpij_Ay(:,0:liney,0:s)
   TAz(0:linez,0:s)=tpTAz(0:linez,0:s); ij_TAz(:,0:linez,0:s)=tpij_Az(:,0:linez,0:s)

   DEALLOCATE(tpTAx,tpTAy,tpTAz)
   DEALLOCATE(tpij_Ax,tpij_Ay,tpij_Az)
   

   ! Detect error during the reading 
   ! -------------------------------------------------------------------------
   if (istat>0) then
      write(6,*) "FringeField ERROR: Reading Error Line ",line
      OKRead=.False.
      stop
   endif
   

   ! Close file
   ! -------------------------------------------------------------------------
   close(10)
   OKRead=.True.
   return
end subroutine
+ei
