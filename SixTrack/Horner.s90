+dk ffhorner
+if ffield
!! ---------------------------------------------------------------------------
!!      Subroutine de calcul du vecteur potentiel au point (x,y,z)
!! ---------------------------------------------------------------------------
subroutine Horner2D(x, y, z, n, m, s, line, ij_Tab, Tab, resultat)
   implicit none

   ! Initialisation des paramettres
   ! -------------------------------------------------------------------------
   integer,intent(in) :: n,m,s                            ! Exposant max pour x et y, et nb de pas en z
   integer,intent(in) :: z                                ! Position en z
   integer,intent(in) :: line                             ! 
   integer :: l                                           ! Indice en x et en y pour les boucles
   integer(kind=2),intent(in) :: ij_Tab(0:1,0:line,0:s)   ! 
   double precision,intent(in) :: x,y                     ! Position en x et y
   double precision :: xpow(0:n),ypow(0:m)                ! 
   double precision,intent(out) :: resultat               ! Valeur du vecteur potentiel au point (x,y,z)
   double precision,intent(in) :: Tab(0:line,0:s)         ! Tableau des coef.
   double precision :: r0                                 ! Variable pour le calcul du vecteur potentiel

   integer :: max_i,max_j                                 ! variable to prevent the SIGFPE
   double precision :: log_tmp

   ! Initialisation des vecteurs xpow et ypow
   ! -------------------------------------------------------------------------
   log_tmp=abs(log10(abs(x)))
   if (log_tmp*(n)>230) then
      max_i=230/log_tmp
   else
      max_i=n
   endif
   log_tmp=abs(log10(abs(y)))
   if (log_tmp*(m)>230) then
      max_j=230/log_tmp
   else
      max_j=m
   endif

   xpow(0)=1.0d0
   do l=1,max_i
      xpow(l)=xpow(l-1)*x 
   enddo
   ypow(0)=1.0d0
   do l=1,max_j
      ypow(l)=ypow(l-1)*y 
   enddo

   
   ! Initialisation de la boucle en x
   ! -------------------------------------------------------------------------
   r0=0.0d0
   do l=0,line
      if ((ij_Tab(0,l,z)<=max_i).and.(ij_Tab(1,l,z)<=max_j)) then
         r0 = r0 + xpow(ij_Tab(0,l,z))*ypow(ij_Tab(1,l,z))*Tab(l,z)
      endif
   enddo
   resultat=r0
end subroutine

!! ---------------------------------------------------------------------------
!!      Subroutine de calcul du vecteur potentiel au point (x,y,z)
!! ---------------------------------------------------------------------------
subroutine HornerDX(x, y, z, n, m, s, line, ij_Tab, Tab, resultat)
   implicit none

   ! Initialisation des paramettres
   ! -------------------------------------------------------------------------
   integer,intent(in) :: n,m,s                            ! Exposant max pour x et y, et nb de pas en z
   integer,intent(in) :: z                                ! Position en z
   integer,intent(in) :: line                             ! 
   integer :: l                                           ! Indice en x et en y pour les boucles
   integer(kind=2),intent(in) :: ij_Tab(0:1,0:line,0:s)   ! 
   double precision,intent(in) :: x,y                     ! Position en x et y
   double precision :: xpow(0:n-1),ypow(0:m)              ! 
   double precision,intent(out) :: resultat               ! Valeur du vecteur potentiel au point (x,y,z)
   double precision,intent(in) :: Tab(0:line,0:s)         ! Tableau des coef.
   double precision :: r0                                 ! Variable pour le calcul du vecteur potentiel
   double precision :: di                                 ! Coefficient du a la derrivee

   integer :: max_i,max_j                                 ! variable to prevent the SIGFPE
   double precision :: log_tmp

   ! Initialisation des vecteurs xpow et ypow
   ! -------------------------------------------------------------------------
   log_tmp=abs(log10(abs(x)))
   if (log_tmp*(n-1)>230) then
      max_i=230/log_tmp
   else
      max_i=n-1
   endif
   log_tmp=abs(log10(abs(y)))
   if (log_tmp*(m)>230) then
      max_j=230/log_tmp
   else
      max_j=m
   endif


   ! Initialisation des vecteurs xpow et ypow
   ! -------------------------------------------------------------------------
   xpow(0)=1.0d0
   do l=1,max_i
      xpow(l)=xpow(l-1)*x 
   enddo
   ypow(0)=1.0d0
   do l=1,max_j
      ypow(l)=ypow(l-1)*y 
   enddo
   
   ! Initialisation de la boucle en x
   ! -------------------------------------------------------------------------
   r0=0.0d0
   do l=0,line
      di=dble(ij_Tab(0,l,z))
      if ((di>0).and.(ij_Tab(0,l,z)-1<=max_i).and.(ij_Tab(1,l,z)<=max_j)) then
         r0 = r0 + di*xpow(ij_Tab(0,l,z) - 1)*ypow(ij_Tab(1,l,z))*Tab(l,z)
      endif
   enddo
   resultat=r0
end subroutine

!! ---------------------------------------------------------------------------
!!      Subroutine de calcul du vecteur potentiel au point (x,y,z)
!! ---------------------------------------------------------------------------
subroutine HornerDY(x, y, z, n, m, s, line, ij_Tab, Tab, resultat)
   implicit none

   ! Initialisation des paramettres
   ! -------------------------------------------------------------------------
   integer,intent(in) :: n,m,s                            ! Exposant max pour x et y, et nb de pas en z
   integer,intent(in) :: z                                ! Position en z
   integer,intent(in) :: line                             ! 
   integer :: l                                           ! Indice en x et en y pour les boucles
   integer(kind=2),intent(in) :: ij_Tab(0:1,0:line,0:s)   ! 
   double precision,intent(in) :: x,y                     ! Position en x et y
   double precision :: xpow(0:n),ypow(0:m-1)              ! 
   double precision,intent(out) :: resultat               ! Valeur du vecteur potentiel au point (x,y,z)
   double precision,intent(in) :: Tab(0:line,0:s)         ! Tableau des coef.
   double precision :: r0                                 ! Variable pour le calcul du vecteur potentiel
   double precision :: dj                                 ! Coefficient du a la derrivee

   integer :: max_i,max_j                                 ! variable to prevent the SIGFPE
   double precision :: log_tmp

   ! Initialisation des vecteurs xpow et ypow
   ! -------------------------------------------------------------------------
   log_tmp=abs(log10(abs(x)))
   if (log_tmp*(n)>230) then
      max_i=230/log_tmp
   else
      max_i=n
   endif
   log_tmp=abs(log10(abs(y)))
   if (log_tmp*(m-1)>230) then
      max_j=230/log_tmp
   else
      max_j=m-1
   endif

   xpow(0)=1.0d0
   do l=1,max_i
      xpow(l)=xpow(l-1)*x 
   enddo
   ypow(0)=1.0d0
   do l=1,max_j
      ypow(l)=ypow(l-1)*y 
   enddo
   
   ! Initialisation de la boucle en x
   ! -------------------------------------------------------------------------
   r0=0.0d0
   do l=0,line
      dj=dble(ij_Tab(1,l,z))
      if ((dj>0).and.(ij_Tab(0,l,z)<=max_i).and.(ij_Tab(1,l,z)-1<=max_j)) then
         r0 = r0 + dj*xpow(ij_Tab(0,l,z))*ypow(ij_Tab(1,l,z) - 1)*Tab(l,z)
      endif
   enddo
   resultat=r0
end subroutine

!! ---------------------------------------------------------------------------
!!      Subroutine de calcul du vecteur potentiel au point (x,y,z)
!! ---------------------------------------------------------------------------
subroutine HornerDYIntX(x, y, z, n, m, s, line, ij_Tab, Tab, resultat)
   implicit none

   ! Initialisation des paramettres
   ! -------------------------------------------------------------------------
   integer,intent(in) :: n,m,s                            ! Exposant max pour x et y, et nb de pas en z
   integer,intent(in) :: z                                ! Position en z
   integer,intent(in) :: line                             ! 
   integer :: l                                           ! Indice en x et en y pour les boucles
   integer(kind=2),intent(in) :: ij_Tab(0:1,0:line,0:s)   ! 
   double precision,intent(in) :: x,y                     ! Position en x et y
   double precision :: xpow(0:n+1),ypow(0:m-1)            ! 
   double precision,intent(out) :: resultat               ! Valeur du vecteur potentiel au point (x,y,z)
   double precision,intent(in) :: Tab(0:line,0:s)         ! Tableau des coef.
   double precision :: r0                                 ! Variable pour le calcul du vecteur potentiel
   double precision :: di,dj                              ! Coefficient du a la derivee ou l'integration

   integer :: max_i,max_j                                 ! variable to prevent the SIGFPE
   double precision :: log_tmp

   ! Initialisation des vecteurs xpow et ypow
   ! -------------------------------------------------------------------------
   log_tmp=abs(log10(abs(x)))
   if (log_tmp*(n+1)>230) then
      max_i=230/log_tmp
   else
      max_i=n+1
   endif
   log_tmp=abs(log10(abs(y)))
   if (log_tmp*(m-1)>230) then
      max_j=230/log_tmp
   else
      max_j=m-1
   endif
   
   xpow(0)=1.0d0
   do l=1,max_i
      xpow(l)=xpow(l-1)*x 
   enddo
   ypow(0)=1.0d0
   do l=1,max_j
      ypow(l)=ypow(l-1)*y 
   enddo
   
   ! Initialisation de la boucle en x
   ! -------------------------------------------------------------------------
   r0=0.0d0
   do l=0,line
!      di=dble(ij_Tab(0,l,z))
      di=dble(ij_Tab(0,l,z) + 1)
      dj=dble(ij_Tab(1,l,z))
      if ((dj>0).and.(ij_Tab(0,l,z)+1<=max_i).and.(ij_Tab(1,l,z)-1<=max_j)) then
        r0 = r0 + dj*xpow(ij_Tab(0,l,z) + 1)*ypow(ij_Tab(1,l,z) - 1)*Tab(l,z)/di

      endif
   enddo
   resultat=r0
end subroutine

!! ---------------------------------------------------------------------------
!!      Subroutine de calcul du vecteur potentiel au point (x,y,z)
!! ---------------------------------------------------------------------------
subroutine HornerDXIntY(x, y, z, n, m, s, line, ij_Tab, Tab, resultat)
   implicit none

   ! Initialisation des paramettres
   ! -------------------------------------------------------------------------
   integer,intent(in) :: n,m,s                            ! Exposant max pour x et y, et nb de pas en z
   integer,intent(in) :: z                                ! Position en z
   integer,intent(in) :: line                             ! 
   integer :: l                                           ! Indice en x et en y pour les boucles
   integer(kind=2),intent(in) :: ij_Tab(0:1,0:line,0:s)   ! 
   double precision,intent(in) :: x,y                     ! Position en x et y
   double precision :: xpow(0:n-1),ypow(0:m+1)            ! 
   double precision,intent(out) :: resultat               ! Valeur du vecteur potentiel au point (x,y,z)
   double precision,intent(in) :: Tab(0:line,0:s)         ! Tableau des coef.
   double precision :: r0                                 ! Variable pour le calcul du vecteur potentiel
   double precision :: di,dj                              ! Coefficient du a la derrivee ou l'integration

   integer :: max_i,max_j                                 ! variable to prevent the SIGFPE
   double precision :: log_tmp

   ! Initialisation des vecteurs xpow et ypow
   ! -------------------------------------------------------------------------
   log_tmp=abs(log10(abs(x)))
   if (log_tmp*(n-1)>230) then
      max_i=230/log_tmp
   else
      max_i=n-1
   endif
   log_tmp=abs(log10(abs(y)))
   if (log_tmp*(m+1)>230) then
      max_j=230/log_tmp
   else
      max_j=m+1
   endif
   
   xpow(0)=1.0d0
   do l=1,max_i
      xpow(l)=xpow(l-1)*x 
   enddo
   ypow(0)=1.0d0
   do l=1,max_j
      ypow(l)=ypow(l-1)*y 
   enddo
   
   ! Initialisation de la boucle en x
   ! -------------------------------------------------------------------------
   r0=0.0d0
   do l=0,line
      di=dble(ij_Tab(0,l,z))
!      dj=dble(ij_Tab(1,l,z))
      dj=dble(ij_Tab(1,l,z) + 1)
      if ((di>0).and.(ij_Tab(0,l,z)-1<=max_i).and.(ij_Tab(1,l,z)+1<=max_j)) then
         r0 = r0 + di*xpow(ij_Tab(0,l,z) - 1)*ypow(ij_Tab(1,l,z) + 1)*Tab(l,z)/dj

      endif
   enddo
   resultat=r0
end subroutine
+ei
